# -*- coding: utf-8 -*-
"""
Created on 2025/9/2

@author: Yifei Sun
"""

import torch
import pyrfm
import json

json_str = """
{
  "material": {
    "relative_permittivity": 2.2,
    "relative_permeability": 1.0,
    "conductivity": 0.0
  },
  "source": {
    "type": "discrete_port",
    "position": 0.10,
    "amplitude": 1.0,
    "phase": 0.0,
    "unit": "V"
  },
  "boundary_conditions": {
    "left":  { "type": "dirichlet", "value": 0.0, "unit": "V"   },
    "right": { "type": "neumann",   "value": 0.0, "unit": "V/m" }
  },
  "frequency": 1.0e9
}
"""

"""
电磁一维 Helmholtz 问题（与所给 JSON 精确对应）


一、问题描述（Problem Statement）
- 物理场：时间谐波 TEM 近似下一维标量场 u(x) ∈ ℂ（与“V”单位对齐，可理解为电压包络）。
- 空间域：x ∈ (0, L)，其中 L > x₀ = 0.10 m（几何长度不在本设定 JSON 中固定）。
- 频率：f = 1.0 GHz，角频率 ω = 2πf。
- 材料：均匀各向同性无耗介质，ε = εᵣ ε₀，μ = μᵣ μ₀，σ = 0。
- 激励：在 x = x₀ 处的离散端口（点源），幅值 A = 1.0，相位 φ = 0（单位“V”）。
- 边界：左端 Dirichlet（u(0) = 0 V，等效短路）；右端 Neumann（u′(L) = 0 V/m，等效开路）。

二、常量与派生波参数（由材料与频率给出）
- 真空常数：ε₀ = 8.854 187 817×10⁻¹² F/m，μ₀ = 4π×10⁻⁷ H/m。
- 相对参数：εᵣ = 2.2，μᵣ = 1.0，σ = 0（无耗）。
- 角频率：ω = 2π × 10⁹ ≈ 6.283 185 307×10⁹ rad/s。
- 相速度：v = 1/√(με) = c₀/√(εᵣ μᵣ) ≈ 2.021 200 339×10⁸ m/s。
- 波长：λ = v/f ≈ 0.202 120 034 m。
- 波数：k = 2π/λ ≈ 31.086 405 362 rad/m。
- 介质本征阻抗：η = √(μ/ε) = η₀/√εᵣ ≈ 253.991 526 Ω（η₀ ≈ 376.730 314 Ω）。
  说明：η 为介质的平面波/TEM 本征阻抗，非几何定义的传输线特性阻抗 Z₀。

三、治理方程（Governing PDE，频域，e^{-iωt} 约定）
在 (0, L) 内，u(x) 满足一维 Helmholtz 方程含点源：
    u″(x) + k² u(x) = − Q δ(x − x₀),     0 < x < L,
其中 δ 为狄拉克 δ，Q ∈ ℂ 为点源强度（频域等效值）。与 JSON 中的
“amplitude = 1.0、phase = 0” 对应，可写
    Q = A·e^{iφ}·𝒩,
A = 1.0，φ = 0。𝒩 为归一化系数（由具体离散/端口定义决定）；在多数 FEM/FD 实现中，
可直接把右端当作 −A δ(x − x₀)，并用“导数跳跃条件”标定实际强度（见下）。

四、点源的等效跳跃条件（用于解析拼接或数值弱式）
令 ε → 0⁺，对 [x₀ − ε, x₀ + ε] 积分可得
    ∫ u″ dx = u′(x₀⁺) − u′(x₀⁻) = − Q.
因此：
    u 在 x₀ 连续：          u(x₀⁺) = u(x₀⁻),
    导数存在跳跃：          u′(x₀⁺) − u′(x₀⁻) = − Q.

五、边界条件（与 JSON 一致）
- 左端 Dirichlet： u(0) = 0 V      （短路、强制电压为零）
- 右端 Neumann：  u′(L) = 0 V/m    （开路、零法向导数/零通量）


"""

if __name__ == "__main__":
    torch.set_default_device('cuda') if torch.cuda.is_available() else torch.set_default_device('cpu')
    input_points = """
0.00000000
0.00010064
0.00040256
0.00090565
0.00160988
0.00251521
0.00362162
0.00492905
0.00643747
0.00814682
0.01005708
0.01216819
0.01448009
0.01699273
0.01970605
0.02261999
0.02573449
0.02904947
0.03256486
0.03628057
0.04019652
0.04431262
0.04862878
0.05314490
0.05786088
0.06277660
0.06789197
0.07320685
0.07872113
0.08443467
0.09034734
0.09645900
0.10276949
0.10927867
0.11598638
0.12289246
0.12999675
0.13729906
0.14479924
0.15249710
0.16039245
0.16848510
0.17677487
0.18526154
0.19394491
0.20282477
0.21190089
0.22117306
0.23064106
0.24030466
0.25016362
0.26021771
0.27046668
0.28091028
0.29154825
0.30238033
0.31340626
0.32462577
0.33603857
0.34764438
0.35944291
0.37143386
0.38361694
0.39599184
0.40855825
0.42131584
0.43426429
0.44740326
0.46073241
0.47425140
0.48795987
0.50185748
0.51594385
0.53021863
0.54468144
0.55933191
0.57416966
0.58919429
0.60440541
0.61980262
0.63538551
0.65115369
0.66710672
0.68324420
0.69956568
0.71607075
0.73275895
0.74962984
0.76668295
0.78391784
0.80133402
0.81893102
0.83670836
0.85466557
0.87280214
0.89111758
0.90961138
0.92828303
0.94713201
0.96615779
0.98535984
1.00000000
    """

    points_list = input_points.strip().split("\n")
    # 转换为浮点数
    points_float = [float(x) for x in points_list]
    # 转换为 PyTorch 张量
    points = torch.tensor(points_float).reshape(-1, 1)

    print(points)

    data = json.loads(json_str)
    print(data)
    x_min = points[:, 0].min()
    x_max = points[:, 0].max()
    print(f"x_min: {x_min}, x_max: {x_max}")
